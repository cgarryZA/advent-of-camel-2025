# Christian Garry Advent of Hardcaml 2025
This repository contains synthesizable FPGA implementations of selected [Advent of Code 2025](https://adventofcode.com/) problems, targeting streaming execution on the ULX3S platform for the [Advent of FPGA Challenge](https://blog.janestreet.com/advent-of-fpga-challenge-2025/).

This project is based on the [Jane Street Hardcaml Template Project](https://github.com/janestreet/hardcaml_template_project/tree/with-extensions/), with the structure and UART infrastructure rebuilt and updated from the [2024 Advent of Hardcaml](https://github.com/asinghani/advent-of-hardcaml-2024/) designs to match current versions of Hardcaml and dune.

I've started with AoC days that had solutions that seemed like they would map well to hardware implementations and will see how many I can finish before the deadline.

## Using the repo

```bash
cd fpga
dune runtest
```

This runs the testbench for each implemented day against the sample input
provided in the Advent of Code problem description. Sample inputs live in:

`/inputs/sampleX.txt`

where `X` is the day number with no leading zeros.

```bash
cd fpga
make run-all
make run-01
```

These commands run all days (or a single day) against the full input from the
Advent of Code website.

The AoC rules ban redistribution of input files, so they are `.gitignore`d and
must be downloaded manually. If you attempt to run a day without its input
present, the runner will print the correct download link and tell you exactly
where to save it:

`https://adventofcode.com/2025/day/X/input`

`/inputs/inputX.txt`

where `X` is the day number with no leading zeros.

## Execution Model

All designs process their inputs as UART streams and produce their outputs over UART. Each solution follows a deterministic load–compute–report structure: input data is received and prepared for processing, the problem-specific algorithm is executed in hardware, and the final results for part 1 and part 2 are formatted as decimal values and transmitted once computation completes.

## Solutions

### Day 1, Part 1 + Part 2  
[Hardcaml solution](fpga/src/day01.ml) // [Problem Link](https://adventofcode.com/2025/day/1)

This design simulates the behaviour of a combination lock driven by a sequence of direction-and-step instructions.

Each instruction updates the lock position within the range \([0, 99]\) using modular arithmetic to account for wraparound. For part 1, the design counts how many instructions result in the lock position landing exactly on zero after the update.

For part 2, the design analytically determines how many times the lock passes through zero while executing each instruction. This is done by computing the distance to the first arrival at zero and then counting subsequent arrivals at fixed intervals, without iterating over individual steps.

Instructions are processed sequentially at a rate of one per cycle, and the per-instruction contributions are accumulated to produce the final results.


### Day 2, Part 1 + Part 2  
[Hardcaml solution](fpga/src/day02.ml) // [Problem Link](https://adventofcode.com/2025/day/2)
This design evaluates numeric ranges stored in external memory and identifies values that satisfy digit-pattern constraints, using a fully streaming binary-to-BCD datapath.

Input ranges are loaded into on-chip RAM as pairs of 64-bit lower and upper bounds. Each range is processed independently. The lower bound is first converted from binary to BCD using a repeated divide-by-10 datapath; this conversion is performed once per range. Subsequent values are generated by incrementing the BCD representation directly, allowing the design to advance one candidate ID per cycle.

For part 1, the circuit checks whether an ID consists of exactly two identical halves (e.g. ABAB). For part 2, the design generalises this check to any repeated substring occurring at least twice. These checks are performed combinationally over the BCD digits using parallel substring comparisons.

The design avoids per-digit iteration in the main loop. All candidates are evaluated in a single pass, with one ID tested per cycle. Valid IDs contribute their numeric value to the corresponding accumulator. The final sums for part 1 and part 2 are emitted once all ranges have been processed.

### Day 3, Part 1 + Part 2  
[Hardcaml solution](fpga/src/day03.ml) // [Problem Link](https://adventofcode.com/2025/day/3)

This design processes each input line as a stream of ASCII digits and computes one result per line for both parts of the problem.

As digits are received, the circuit maintains running candidates representing the largest values that can be formed using exactly \(n\) digits from the current line, for all relevant values of \(n\). When a new digit arrives, each candidate is updated by either retaining its previous value or by appending the new digit to the best candidate of length \(n-1\), selecting whichever option yields the larger result. These updates are performed in parallel for all candidate lengths.

When a line boundary is encountered, the candidates corresponding to sequence lengths 2 and 12 are committed to the running totals for part 1 and part 2 respectively, and the per-line state is reset before processing the next line.

The computation proceeds in a single pass over the input, advancing one digit per cycle with a fixed amount of state.

### Day 4, Part 1 + Part 2  
[Hardcaml solution](fpga/src/day04.ml) // [Problem Link](https://adventofcode.com/2025/day/4)

This design implements a parametrised two-dimensional stencil engine operating over a padded grid domain.

The computation proceeds by repeatedly scanning the grid using a sliding 3×3 window. Neighbourhood values are constructed using line buffers and shift registers, allowing all eight neighbours of each cell to be evaluated concurrently. For each cell, the number of active neighbours is computed using a bit-sliced population count, and the cell is conditionally removed based on this count.

The algorithm runs iteratively. The first full scan records the number of removed cells for part 1. Subsequent scans continue updating the grid until no further removals occur, accumulating the total number of removed cells across all passes for part 2. The grid state alternates between two buffers between passes.

During each scan, one packed word is processed per cycle. The design is parameterised by grid dimensions and processing width.

### Day 5, Part 1 + Part 2  
[Hardcaml solution](fpga/src/day05.ml) // [Problem Link](https://adventofcode.com/2025/day/5)

This design processes a set of numeric ranges and query items, performing range merging followed by membership testing.

Input data is streamed into RAM and interpreted as two sequences: a list of half-open ranges and a list of individual items. In the first phase, the circuit reads and merges overlapping or adjacent ranges. This is implemented as a single-pass merge engine that maintains a current active range and emits merged ranges back into RAM as they are completed.

For part 2, the design accumulates the total coverage of all merged ranges by summing their lengths during the merge phase.

For part 1, each item is tested against the merged ranges. Items and ranges are both traversed in ascending order, allowing early termination when an item is known to lie outside all remaining ranges. This avoids unnecessary comparisons and ensures the query phase remains linear in the size of the input.

The entire computation is performed without sorting in hardware, relying instead on the problem’s ordering guarantees. All memory accesses are sequential, and the design uses a small finite-state machine to coordinate merge, flush, and query phases.

### Day 6, Part 1 + Part 2  
[Hardcaml solution](fpga/src/day06.ml) // [Problem Link](https://adventofcode.com/2025/day/6)

This design evaluates a stream of arithmetic expressions encoded as a compact byte format, supporting both additive and multiplicative reductions.

The input is parsed directly from RAM as a byte stream. Each expression begins with an operator mode (add or multiply), followed by a count and a sequence of 16-bit values. Expressions are processed sequentially using a small FSM that decodes operands, accumulates intermediate results, and commits completed expressions to a running total.

For part 1 and part 2, the same datapath is reused, with a phase flag selecting which stream of expressions contributes to which result. A zero count acts as a delimiter between the two phases.

The design avoids buffering entire expressions. Instead, each value is folded into an accumulator as soon as it is decoded, allowing the computation to proceed in a single pass with minimal state. Final results are emitted once the end-of-stream delimiter is encountered.

### Day 9, Part 1  
[Hardcaml solution](fpga/src/day09.ml) // [Problem Link](https://adventofcode.com/2025/day/9)

This design computes the largest axis-aligned rectangle defined by two points in a set of integer coordinates.

All points are loaded into RAM as (x, y) pairs. The design performs a double nested iteration over point pairs (A, B), computing the inclusive rectangle area defined by their Manhattan extents. Absolute differences are computed combinationally, and the resulting width and height are multiplied to form a 128-bit area value.

A running maximum is maintained across all pairs. The nested iteration is implemented using two counters and a small FSM, ensuring each unique pair is evaluated exactly once.

Although the algorithm is quadratic in the number of points, it maps cleanly to hardware due to its regular memory access pattern and simple arithmetic. The final maximum area is emitted once all pairs have been processed.
