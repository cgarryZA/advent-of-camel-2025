<a name="day-10"></a>
### Day 10 Part 1

<p>
<a href="#solutions"><img src="https://img.shields.io/badge/Back_to-Solutions-8b949e"></a>
<a href="fpga/src/day10.ml"><img src="https://img.shields.io/badge/Code-day10.ml-f85149"></a>
<a href="https://adventofcode.com/2025/day/10"><img src="https://img.shields.io/badge/AoC-Problem-facc15"></a>
</p>

This design streams a sequence of independent “machines” from RAM and solves each one with a bounded brute-force subset search over up to 16 control inputs.

Input words are loaded into RAM over UART. The first word gives the machine count, followed by a per-machine header and a variable-length list of 64-bit masks. Each header encodes the number of active output bits m, the number of available buttons k, and a 48-bit target state. A mask is generated from m so equality checks only consider the low m bits.

For each machine, the first 16 masks are cached into registers and the circuit enumerates all subsets of the k buttons (clipped to 16 in hardware). Each subset produces an XOR-reduced 64-bit state by conditionally including each cached mask. The result is compared against the target under the m-bit mask, and the subset popcount is used as the cost. The best (minimum) popcount across all valid subsets is accumulated into the running total for part 1.

RAM access is explicitly scheduled as a 1-cycle read pipeline: addresses are set in one state, then consumed the next cycle. The design uses a small FSM to step through “read header”, “read masks”, “subset sweep”, and “advance to next machine” phases, emitting the final part 1 total once all machines have been processed.
