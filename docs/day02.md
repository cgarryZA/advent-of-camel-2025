
<a name="day-2"></a>
### Day 2, Part 1 + Part 2

<p>
<a href="../README.md#solutions"><img src="https://img.shields.io/badge/Back_to-Solutions-8b949e"></a>
<a href="fpga/src/day02.ml"><img src="https://img.shields.io/badge/Code-day02.ml-f85149"></a>
<a href="https://adventofcode.com/2025/day/2"><img src="https://img.shields.io/badge/AoC-Problem-facc15"></a>
</p>

This design evaluates numeric ranges stored in external memory and identifies values that satisfy digit-pattern constraints, using a fully streaming binary-to-BCD datapath.

Input ranges are loaded into on-chip RAM as pairs of 64-bit lower and upper bounds. Each range is processed independently. The lower bound is first converted from binary to BCD using a repeated divide-by-10 datapath; this conversion is performed once per range. Subsequent values are generated by incrementing the BCD representation directly, allowing the design to advance one candidate ID per cycle.

For part 1, the circuit checks whether an ID consists of exactly two identical halves (e.g. ABAB). For part 2, the design generalises this check to any repeated substring occurring at least twice. These checks are performed combinationally over the BCD digits using parallel substring comparisons.

The design avoids per-digit iteration in the main loop. All candidates are evaluated in a single pass, with one ID tested per cycle. Valid IDs contribute their numeric value to the corresponding accumulator. The final sums for part 1 and part 2 are emitted once all ranges have been processed.
