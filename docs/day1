<a name="day-1"></a>
### Day 1, Part 1 + Part 2

<p>
<a href="#solutions"><img src="https://img.shields.io/badge/Back_to-Solutions-8b949e"></a>
<a href="fpga/src/day01.ml"><img src="https://img.shields.io/badge/Code-day01.ml-f85149"></a>
<a href="https://adventofcode.com/2025/day/1"><img src="https://img.shields.io/badge/AoC-Problem-facc15"></a>
</p>

This design simulates the behaviour of a combination lock driven by a sequence of direction-and-step instructions.

Each instruction updates the lock position within the range \([0, 99]\) using modular arithmetic to account for wraparound. For part 1, the design counts how many instructions result in the lock position landing exactly on zero after the update.

For part 2, the design analytically determines how many times the lock passes through zero while executing each instruction. This is done by computing the distance to the first arrival at zero and then counting subsequent arrivals at fixed intervals, without iterating over individual steps.

Instructions are processed sequentially at a rate of one per cycle, and the per-instruction contributions are accumulated to produce the final results.
